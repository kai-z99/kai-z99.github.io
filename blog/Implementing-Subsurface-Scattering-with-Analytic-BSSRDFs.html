<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implementing Subsurface Scattering with Analytic BSSRDFs</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            background: #fff;
            color: #222;
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        .container {
            max-width: 700px;
            margin: 60px auto 0 auto;
            padding: 32px 24px;
            background: #fff;
            box-shadow: 0 2px 8px rgba(0, 0, 0, 0.04);
            border-radius: 8px;
        }

        h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5em;
            font-weight: 600;
        }

        .post-meta {
            color: #888;
            font-size: 1rem;
            margin-bottom: 2em;
        }

        .post-content {
            font-size: 1.15rem;
            line-height: 1.7;
        }

        a.back-link {
            display: inline-block;
            margin-bottom: 2em;
            color: #0077cc;
            text-decoration: none;
            font-size: 1rem;
        }

        a.back-link:hover {
            text-decoration: underline;
        }

        pre code {
            display: block;
            background: #f5f5f5;
            color: #222;
            padding: 14px 16px;
            border-radius: 6px;
            font-size: 1em;
            line-height: 1.5;
            overflow-x: auto;
            max-width: 100%;
            box-sizing: border-box;
        }

        .media {
            margin: 0 auto 1em;
            text-align: center;
            max-width: min(100%, 900px);
        }

        .media img {
            display: block;
            margin: 0 auto;
            max-width: 100%;
            border-radius: 8px;
        }

        .media figcaption {
            color: #797979;
            font-size: 0.85em;
            font-style: italic;
            margin-top: .5em;
        }
    </style>
</head>

<body>
    <div class="container">
        <a href="index.html" class="back-link">&larr; Back to Blog</a>
        <h1>Implementing Subsurface Scattering with Analytic BSSRDFs</h1>
        <div class="post-meta" style="margin-bottom:1.5em;">Kai Zhang</div>

        <figure class="media">
            <img id="scene-image" src="../images/xyz10000spp10.0-0.2NL.png" alt="Overhead · ℓ = 10.0">
            <figcaption id="scene-caption">
                XYZ dragon (350 cm) rendered with different mean free path values.
                Overhead area light emitted radiance \(L_e = 8\); sky radiance \(L_{\text{sky}} = (0.49, 0.56, 0.70)\).
            </figcaption>
          </figure>
          
          <!-- Controls -->
          <div style="display:flex; flex-direction:column; gap:.75em; justify-content:center; align-items:center; margin-bottom:2em;">
            <!-- Scene buttons -->
            <div role="group" aria-label="Scene" style="display:flex; gap:.5em;">
              <button class="scene-btn" data-scene="sky">Sky</button>
              <button class="scene-btn" data-scene="backlight">Backlight</button>
            </div>
            <!-- ell buttons -->
            <div role="group" aria-label="Mean free path" style="display:flex; gap:.5em;">
              <button class="ell-btn" data-ell="10.0">\(\ell = 10.0\)</button>
              <button class="ell-btn" data-ell="1.0">\(\ell = 1.0\)</button>
              <button class="ell-btn" data-ell="0.1">\(\ell = 0.1\)</button>
            </div>
          </div>
          
          <script>
            const IMAGE_MAP = {
              sky: {
                "10.0": { src: "../images/skylight2048spp-10.0.png",
                caption: "XYZ dragon (350 cm), Overhead light \\(L_e = 8\\); sky \\(L_{\\\\{sky}}=(0.49,0.56,0.70)\\)."},
                "1.0": { src: "../images/skylight2048spp-1.0.png",
                         caption: "XYZ dragon (350 cm), Overhead light \\(L_e = 8\\); sky \\(L_{\\\\{sky}}=(0.49,0.56,0.70)\\)." },
                "0.1": { src: "../images/skylight2048spp-0.1.png",
                         caption: "XYZ dragon (350 cm), Overhead light \\(L_e = 8\\); sky \\(L_{\\\\{sky}}=(0.49,0.56,0.70)\\)." }
              },
              backlight: {
                "10.0": { src: "../images/backlight4096spp-10.0.png",
                          caption: "Backlight \\(L_e = 17\\). Note how light exits from the front at higher mean free path values." },
                "1.0":  { src: "../images/backlight4096spp-1.0.png",
                          caption: "Backlight \\(L_e = 17\\). Note how light exits from the front at higher mean free path values." },
                "0.1":  { src: "../images/backlight4096spp-0.1.png",
                          caption: "Backlight \\(L_e = 17\\). Note how light exits from the front at higher mean free path values." }
              }
            };
          
            const imgEl = document.getElementById("scene-image");
            const capEl = document.getElementById("scene-caption");
            const sceneBtns = document.querySelectorAll(".scene-btn");
            const ellBtns = document.querySelectorAll(".ell-btn");
          
            // State
            let currentScene = "sky";
            let currentEll = "10.0";
          
            // Helpers
            function setActive(btns, value, attr) {
              btns.forEach(b => {
                const isActive = b.dataset[attr] === value;
                b.disabled = isActive; 
                b.setAttribute("aria-pressed", isActive ? "true" : "false");
              });
            }
          
            function updateImage() {
              const entry = IMAGE_MAP[currentScene][currentEll];
              imgEl.src = entry.src;
              imgEl.alt = `${capitalize(currentScene)} · ℓ = ${currentEll}`;
              capEl.innerHTML = entry.caption;
              if (window.MathJax && MathJax.typesetPromise) MathJax.typesetPromise([capEl]);
            }
          
            function capitalize(s){ return s.charAt(0).toUpperCase() + s.slice(1); }
          
            // Event wiring
            sceneBtns.forEach(btn => {
              btn.addEventListener("click", () => {
                currentScene = btn.dataset.scene;
                setActive(sceneBtns, currentScene, "scene");
                updateImage();
                // Preload the other ℓ variants for the newly chosen scene
                preloadScene(currentScene);
              });
            });
          
            ellBtns.forEach(btn => {
              btn.addEventListener("click", () => {
                currentEll = btn.dataset.ell;
                setActive(ellBtns, currentEll, "ell");
                updateImage();
              });
            });
          
            // Preload all images (lightweight + avoids flicker)
            function preloadScene(scene){
              Object.values(IMAGE_MAP[scene]).forEach(({src}) => { const im = new Image(); im.src = src; });
            }
            function preloadAll(){
              Object.keys(IMAGE_MAP).forEach(preloadScene);
            }
          
            // Init UI to match initial <img> src
            setActive(sceneBtns, currentScene, "scene");
            setActive(ellBtns, currentEll, "ell");
            preloadAll();
            updateImage();
          </script>
          

        <div class="post-content">
            <p>Subsurface scattering (SSS) can create interesting visuals in a render. Although the theory is availible online, 
                implementation can be confusing. This post will explain how to implement a physically based SSS model into your path 
                tracer using analytic bidirectional scattering surface reflectance distribution functions (BSSRDFs).
                Note that this in context of single sample MIS.
            </p>
            <p>In SSS, light enters a point on a surface, then re-emerges at a point that may or may not be where it
                first entered. Looking at the rendering equation:</p>
            <p>
                $$
                L_o(p_o, \omega_o) = \int_{\Omega} f_r(p_o, \omega_i, \omega_o) L_i(p_o, \omega_i) (\omega_i \cdot n_i)
                d\omega_i
                $$
            </p>
            <p>The monte carlo estimator is:</p>
            <p>
                $$
                L_o(p_o, \omega_o) \approx \frac{1}{N}\sum_{i=1}^{N}{\frac{f_r(p_o, \omega_i, \omega_o) L_i(p_o,
                \omega_i) (\omega_i \cdot n_i)}{p(\omega_i)}}
                $$
            </p>


            <p>We can see that it only supports light entering and exiting at one point. Therefore we to use the BSSRDF, which can account for
                distinct entrance and exit points:
            </p>
            <p>
                $$
                L_o(p_o, \omega_o) = \int_A \int_{\Omega} S(p_o, \omega_o, p_i, \omega_i) L_i(p_o, \omega_i) (\omega_i
                \cdot n_i) d\omega_i dA
                $$
            </p>
            <p>As you can see, instead of integrating just the hemisphere around a point, we must integrate over the entire 
                surface of the object \(A\), to account for all possible points of light entry.</p>
            <p>Of course the integral in this form is quite difficult to evaluate. Luckily in 2001, <a
                    href="http://www.graphics.stanford.edu/papers/bssrdf/bssrdf.pdf" target="_blank"
                    rel="noopener noreferrer">Jensen et al proposed a more manageable form</a> of the BSSRDF term called
                the separable BSSRDF:</p>
            <p>
                $$
                S(p_o, \omega_o, p_i, \omega_i) = (1 - F(\omega_o)) S_p(p_o, p_i) S_\omega(\omega_i)
                $$
            </p>
            <p>Therefore the rendering equation becomes:</p>
            <p>
                $$
                L_o(p_o, \omega_o) = (1 - F(\omega_o))\int_{A} S_p(p_o, p_i) \int_{\Omega}L_i(p_o, \omega_i)S_{\omega}(\omega_i)(\omega_i
                \cdot n_i) d\omega_idA
                $$
            </p>
            <p>Then the monte carlo estimator is:</p>
            <p>
                $$
                L_o(p_o, \omega_o) \approx (1 - F(\omega_o))\frac{1}{N}\sum_{i=1}^{N}{\frac{ L_i(p_o, \omega_i) S_p(p_o,
                p_i) S_\omega(\omega_i) (\omega_i \cdot n_i)}{p(\omega_i)p(p_i)}}
                $$
            </p>
            <p>I will now explain how to integrate each term into your Monte Carlo path tracer.</p>
            <div style="margin-top:2em;">\((1 - F(\omega_o))\)</div>
            <p>This term essentially accounts for whether the light actually enters the surface and scatters. So it is
                actually just your BSDF's chance of transmission with \(\omega_o\). If its true, we evaulate the BSSRDF.
            </p>
            <p>If you dont have a full BSDF system, draw a random number uniformly \(u_1 \in [0, 1]\) and test \(u_1 < 1
                    - F(\omega_o)\). If it fails, simply fall back to something like a reflection lobe. Otherwise we
                    evaulate the BSSRDF. For multi-sample MIS, please refer to pbrt.</p>
                    <div style="margin-top:2em;">\(S_\omega(\omega_i)\)</div>
                    <p>This term accounts for the energy loss when the ray exits the surface. Here is the function (from
                        <a href="https://pbr-book.org/3ed-2018/Volume_Scattering/The_BSSRDF" target="_blank"
                            rel="noopener noreferrer">pbrt 11.7</a>):</p>
                    <p>
                        $$
                        S_\omega(\omega_i) = \frac{1 - F_r(\cos \theta_i)}{c \pi}
                        $$
                    </p>
                    <p>where</p>
                    <p>
                        $$
                        c = 1 - 2 \int_0^{\frac{\pi}{2}} F_r(\eta, \cos \theta) \sin \theta \cos \theta \, d\theta
                        $$
                    </p>
                    <p>This integral can be precomputed using this function:</p>
                    <pre><code>__device__ inline float FresnelMoment1(float invEta)
{
    float e = invEta;
    float e2 = e * e, e3 = e2 * e, e4 = e2 * e2, e5 = e3 * e2;
    if (e < 1.0f)
        return 0.45966f - 1.73965f * e + 3.37668f * e2 - 3.904945f * e3 + 2.49277f * e4 - 0.68441f * e5;
    else
        return -4.61686f + 11.1136f * e - 10.4646f * e2 + 5.11455f * e3 - 1.27198f * e4 + 0.12746f * e5;
}
</code></pre>
                    <p>Please refer to <a
                            href="https://pbr-book.org/3ed-2018/Volume_Scattering/The_BSSRDF#SeparableBSSRDFs"
                            target="_blank" rel="noopener noreferrer">pbrt 11.4.3</a> for derivation.</p>
                    <div style="margin-top:2em;">\(S_p(p_o, p_i)\)</div>
                    <p>This term is the spatial term and accounts for energy when the light scatters under the surface.
                        We make the simplifying assumption:</p>
                    <p>
                        $$
                        S_p(p_o, p_i) \approx S_r(\|p_o - p_i\|)
                        $$
                    </p>
                    <p>So that the only factor affecting this term is the distance between the entrance and exit of the
                        light. There are different variations of diffusion profiles, which generally are functions that
                        approximate \(S_p\). I decided to use <a
                            href="https://graphics.pixar.com/library/ApproxBSSRDF/paper.pdf" target="_blank"
                            rel="noopener noreferrer">this one described by Disney.</a>:</p>
                    <p>
                        $$
                        S_r(\|p_o - p_i\|) = R'(r) = \frac{e^{-r/d} + e^{-r/(3d)}}{8 \pi d r}
                        $$
                    </p>
                    <div style="margin-left:1.5em; color:#797979; font-size:0.85em;">
                        <em>Note that the diffusion profile is normalized, therefore:
                            <p>
                                $$
                                \int_{0}^{2\pi}\int_{0}^{\infty}{rR'(r) drd \phi} = 1
                                $$
                            </p>
                        </em>
                    </div>
                    <p>Since we want to express it with meaningful physical properties, Disney gave it some params:</p>
                    <p>
                        $$
                        R(r) = A s \frac{e^{-sr/\ell} + e^{-sr/(3\ell)}}{8 \pi \ell r}
                        $$
                    </p>
                    <p>Here \(r\) is the distance from the entrance and exit points.</p>
                    <p> \(\ell\) is the user controlled mean free path which essentially is the average distance the
                        light ray travels between scattering events in the medium.</p>
                    <p>\(A\) in the diffusion profile represents our user defined material albedo.</p>
                    <div style="margin-left:1.5em; color:#797979; font-size:0.85em;">
                        <em>Technically, \(A\) actually is a 1-1 mapping for \(\rho_{eff}\), the effective albedo, as
                            described in
                            <a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering/The_BSSRDF#eq:bssrdf-effective-albedo"
                                target="_blank" rel="noopener noreferrer">pbrt 11.11</a>.
                            Effective albedo, as pbrt states, is "the material’s overall albedo", seperate from
                            \(\rho\), the single scattering albedo. Effective albedo is defined as:
                            <p>
                                $$
                                \rho_{eff} = \int_{0}^{2\pi}\int_{0}^{\infty}{rS_r(r) drd \phi}
                                $$
                            </p>
                            <p>Where \(S_r(r)\) is the diffusion profile. For Disney's profile:</p>
                            <p>
                                $$
                                \rho_{eff} = \int_{0}^{2\pi}\int_{0}^{\infty}{rR(r) drd \phi} =
                                \int_{0}^{2\pi}\int_{0}^{\infty}{rAR'(r) drd \phi} =
                                A\int_{0}^{2\pi}\int_{0}^{\infty}{rR'(r) drd \phi}
                                $$
                            </p>
                            <p>Since \(R'(r)\) is normalized:</p>
                            <p>
                                $$
                                \int_{0}^{2\pi}\int_{0}^{\infty}{rR'(r) drd \phi} = 1
                                $$
                            </p>
                            <p>So it follows that:</p>
                            <p>
                                $$
                                \rho_{eff} = A
                                $$
                            </p>
                            <p>Essentially what this means is that whatever you set \(A\) to, the materials effective
                                albedo will be exactly that, which is good for artists.</p>
                        </em>
                    </div>

            </p>
            <p> Finally, \(s\) is the shape parameter, defined as</p>
            <p style="text-align:center; margin: 1.5em 0;">
                $$
                s = 1.85 - A_{channel} + 7|A_{channel} - 0.8|^3
                $$
            </p>
            <p>\(A_{channel}\) is the value of the rgb channel that is randomly selected when sampling. More info on this in the next
                section.</p>
            <h2>Importance Sampling</h2>
            <p>The next question is, how do we decide our enter and exit points \(p_i\), \(p_o\) to evaluate the
                separable BSSRDF? We need to use importance sampling. Essentially I will describe a simplified version
                of the disk sampling described in <a
                    href="https://pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Subsurface_Reflection_Functions"
                    target="_blank" rel="noopener noreferrer">pbrt 15.4</a>.</p>
            <p>So let's say you shoot a ray into the scene, it intersects a surface and passes the <span
                    style="white-space:nowrap;">\((1 - F(\omega_o))\)</span> test, meaning it has entered the surface
            </p>
            <ol style="margin-left:1.5em;">
                <li>Get the point of intersection and its normal. That is your \(p_o\).</li>
                <li>Choose a random axis on the orthonormal basis with chance \(T:0.25, B:0.25, N:0.5\) (let's call it
                    \(n_{axis}\)). Randomly choose an rgb channel uniformly.</li>
                <li>Draw a sphere at that point that encapsulates 99.9% of the energy of the diffusion profile.
                    Everything outside of it is negligible.
                    <div style="margin-left:1.5em; color:#797979; font-size:0.97em;">
                        <em>Explanation on how to get radius of this sphere in upcoming section.</em>
                    </div>
                </li>
                <li>Create a disk that is tangent to \(n_{axis}\) and has the radius which is the same as the max energy
                    sphere.</li>
                <li>Choose a point on that disk based on the diffusion profile's CDF.
                    <div style="margin-left:1.5em; color:#797979; font-size:0.97em;">
                        <em>I’ll explain how to sample the diffusion profile’s CDF in the upcoming section.</em>
                    </div>
                </li>
                <li>Cast a probe ray at that point, parallel to the \(n_{axis}\), whose length reaches the size of the
                    sphere.</li>
                <div style="margin-left:1.5em; color:#797979; font-size:0.97em;">
                    <em>I’ll explain how to create this ray in the upcoming section.</em>
                </div>
                <li>Gather every intersection in a linked list, and remove any that are not apart of the model. (For
                    example, a wall near the model.)</li>
                <li>Uniformly choose a random intersection point. Get the normal and position of that intersection. That
                    is your \(p_i\) and \(n_i\).</li>
                <li>Sample from a diffuse lobe at \(p_i\) to get the incoming direction \(w_i\).</li>
                <div style="margin-left:1.5em; color:#797979; font-size:0.97em;">
                    <em>More detail on this in upcoming section.</em>
                </div>
            </ol>
            <img src="../images/sampleRadius.png" alt="sampling method" width="600" height="350">
            <h3>Sampling on a Disk with Burley's Diffusion Profile</h3>
            <p>Previously I mentioned we must choose a point on that disk based on the diffusion profile's CDF. This is
                the importance sampling part. Essentially, we want to pick points on the disk that give the most
                contribution to our evaluation of <span style="white-space:nowrap;">\(R(r)\)</span>.</p>
            <p>Disney provided us with the CDF in the paper:</p>
            <p>
                $$
                \text{CDF}(r) = 1 - \frac{1}{4} e^{-r/d} - \frac{3}{4} e^{-r/(3d)}
                $$
            </p>
            <p>Although the original paper claims this CDF is not analytically invertible, <a
                    href="https://zero-radiance.github.io/post/sampling-diffusion/" target="_blank"
                    rel="noopener noreferrer">Zero Radiance in 2019 proved it in fact was</a>:</p>
            <p style="text-align:center; margin: 1.5em 0;">
                $$
                \frac{r}{d} = 3 \log\left(\frac{1 + G(u)^{-1/3} + G(u)^{1/3}}{4u}\right),
                $$
            </p>
            <p style="text-align:center; margin: 1.5em 0;">
                $$
                G(u) = 1 + 4u\left(2u + \sqrt{1 + 4u^2}\right)
                $$
            </p>
            <p>So here is the code that gives you a radial distance on the disk based on that inverse CDF (directly from
                Zero Radiance's Blog):</p>
            <pre style="margin: 1.5em 0;"><code>__device__ inline void SampleBurleyRadius(float u, float rcpS, float& r, float& rcpPdf)
{
    const float LOG2_E = 1.44269504089f;
    u = 1.0f - u; 

    float g = 1.0f + (4.0f * u) * (2.0f * u + sqrtf(1.0f + (4.0f * u) * u));
    float n = exp2f(log2f(g) * (-1.0f / 3.0f));             
    float p = (g * n) * n;                         
    float c = 1.0f + p + n;                                  
    float x = (3.0f / LOG2_E) * log2f(c / (4.0f * u));       
    float rcpExp = ((c * c) * c) / ((4.0f * u) * ((c * c) + (4.0f * u) * (4.0f * u)));

    r = x * rcpS;
    rcpPdf = (8.0f * pi * rcpS) * rcpExp;
}
</code></pre>
            <p> Please note that the above code
                assumes \(\ell = 1\). To convert it to take in any \(\ell\), simply multiply:</p>
            <pre style="margin: 0.5em 0 1.5em 0;"><code>r *= ell;
</code></pre>
            <p>Even though this function also nicely provides a PDF, we won't use it so we can use our own for clarity.
                But by all means, if you don't mind, you can use the one returned by the function.</p>
            <p>Once you have that radial distance \(r\), draw a random \(\phi \in [0, 2\pi]\) uniformly for the
                azimuthal angle on the disk. You have now successfully sampled a point on the disk in polar coordinates
                \(p(r, \phi)\).</p>
            <p>You can convert this into a tangent space vector as:
                \[
                p_{offset} = r (\cos(\phi)\, \mathbf{T} + \sin(\phi)\, \mathbf{B})
                \]
                where \(\mathbf{T}\) and \(\mathbf{B}\) are the tangent and bitangent vectors of the disk's plane.</p>
            <h3>Creating the Energy Sphere</h3>
            <p>To create a sphere with radius \(r\) that encapsulates 99.9% of the energy of \(R(r)\), we can simply
                sample the above mentioned routine with \(u = 0.999\).</p>
            <h3>Creating the Probe Ray</h3>
            <p>As mentioned previously, we want to probe our scene based on the point on our disk. This ray will have
                length:</p>
            <p>
                $$
                l = 2\sqrt{r_{max}^2 - r^2}
                $$
            </p>
            <p>This is essentially the length of the point on our disk projected onto the top and bottom of our energy
                sphere. The direction of this ray will
                be the direction of your orthonormal basis' normal, \(n_{axis}\).
            </p>
            <p>The position of the ray will therefore be: </p>
            <p>
                $$
                p_{ray} = p_o + p_{offset} - n_{axis}(\frac{l}{2})
                $$
            </p>
            <p>This is much easier to visualize, so heres a very nice illustration courtesy of
                <a href="https://gao-duan.github.io/blogs/bssrdf/index.html" target="_blank"
                    rel="noopener noreferrer">Duan Gao</a>
                :
            </p>
            <img src="../images/rayProbe.png" alt="ray probe image" width="600" height="400">
            <p>The bottom black dot (labelled "target") is \(p_{ray}\), the orange dot is \(p_o\), and the blue dot is
                \(p_{offset}\).
                Hopefully it is clear why we need the \(n_{axis}(\frac{l}{2})\) term for \(p_{ray}\).
                <em>(It moves it down to the edge of the sphere.)</em>
            </p>
            <h3>Getting The Exit Direction \(\omega_i\)</h3>
            <p>
                Once we have our entrance point \(p_i\), we can decide the direction on it by simply sampling a
                lambertian lobe at \(p_i\).
                Make sure to save the pdf as this is actually \(p(\omega_i)\) described in our estimator.
            </p>
            <div style="margin-left:1.5em; color:#797979; font-size:0.97em;">
                <em>
                    Technically, youre free to sample any lobe as long as you provide the correct pdf. The BSSRDF
                    happens to have an
                    angular term which is why lambertian is optimal.
                </em>
            </div>

            <h3>Resolving PDFs \(p(\omega_i)\) and \(p(p_i)\)</h3>
            <p>Recall our monte carlo estimator:</p>
            <p>
                $$
                L_o(p_o, \omega_o) \approx (1 - F(\omega_o))\frac{1}{N}\sum_{i=1}^{N}{\frac{ L_i(p_o, \omega_i) S_p(p_o,
                p_i) S_\omega(\omega_i) (\omega_i \cdot n_i)}{p(\omega_i)p(p_i)}}
                $$
            </p>

            <p>We need to find the correct PDFs now; \(p(p_i)\) to account for picking our entrance point, and
                \(p(\omega_i\))
                to account the incoming lights direction.
            </p>
            <p>As discussed earlier, \(p(\omega_i\)) is exactly the pdf for a lambertian sample: </p>
            <p>
                $$
                p(\omega_i) = \frac{cos(\theta_i)}{\pi}
                $$
            </p>

            <p>
                To account for picking the entrance point \(p_i\), we can observe that the diffusion profile \(R(r)\)
                gives the energy when exiting at distance \(r\),
                and importance sampling points proportional to that energy makes the pdf just the normalized diffusion
                profile:
            </p>
            <p>
                $$
                p(p_i) = s \frac{e^{-sr/\ell} + e^{-sr/(3\ell)}}{8 \pi \ell r}
                $$
            </p>
            <div style="margin-left:1.5em; color:#797979; font-size:0.8em;">
                <em>
                    If you're not convinced, we can derive it. For \(p(p_i)\), we want to find:
                    <p>
                        $$
                        p(p_i) = \frac{R(r)}{\int_{0}^{2\pi} \int_{0}^{\infty}rR(r)drd\phi}
                        $$

                    </p>
                    <p>Since the diffusion profile is normalized:</p>
                    <p>
                        $$
                        \int_{0}^{2\pi}\int_{0}^{\infty}{rR'(r) drd \phi} = 1
                        $$
                    </p>
                    <p>Therefore:</p>
                    <p>
                        $$
                        \int_{0}^{2\pi} \int_{0}^{\infty}rR(r)drd\phi = \int_{0}^{2\pi} \int_{0}^{\infty}rAR'(r)drd\phi
                        = A\int_{0}^{2\pi} \int_{0}^{\infty}rR'(r)drd\phi = A
                        $$
                    </p>
                    <p>Plug it back in:</p>
                    <p>
                        $$
                        p(p_i) = \frac{R(r)}{A} = \frac{AR'(r)}{A} = R'(r)
                        $$
                    </p>
                </em>
            </div>
            <p>For multi-sample MIS, we should also include the random selection probablities. Please refer to pbrt.</p> 
            <h3>Checking our Work</h3>
            <p>
                Knowing you've implemented SSS correctly can be tricky and unreliable just by looking at it visually. One easy statistical check for energy conservation
                uses the fact: 
            </p>
            <p>
                $$
                \int_{0}^{2\pi}\int_{0}^{\infty}{rR(r) drd \phi} = A, \int_{\Omega}S_{\omega}(\omega_i)(\omega_i \cdot n_i)d\omega_i = 1
                $$
            </p>
            <p>
                Meaning that the average energy for all your BSSRDF samples for each material should be pretty much exactly \(A\) for that material. For example,
                in your intergrator, if the ray exhibited SSS:
            </p>
            <pre style="margin: 1.5em 0;"><code>float cosine = fmaxf(glm::dot(scattered.direction(), rec.normal), 0.0f);
glm::vec3 contrib = evaluation * cosine / pdf;
                
if (prevSSS) 
{
    atomicAdd(&sssEnergySumR, (double)contrib.r);
    atomicAdd(&sssEnergySumG, (double)contrib.g);
    atomicAdd(&sssEnergySumB, (double)contrib.b);
    atomicAdd(&sssHitCount, 1ull);  
}
</code></pre>
            <p>Then after rendering, check the average:</p>
            <pre style="margin: 1.5em 0;"><code>printf("SSS samples: %llu, Avg Energy: (%lf, %lf, %lf)\n", sssHitCount, sssEnergySumR/(double)sssHitCount, sssEnergySumG / (double)sssHitCount, sssEnergySumB / (double)sssHitCount);
</code></pre>
            <h2>Conclusion</h2>
            <p>
                Hopefully now you know how to calculate each piece of the Monte Carlo estimator:
            </p>
            <p>
                $$
                L_o(p_o, \omega_o) \approx (1 - F(\omega_o))\frac{1}{N}\sum_{i=1}^{N}{\frac{ L_i(p_o, \omega_i) S_p(p_o,
                p_i) S_\omega(\omega_i) (\omega_i \cdot n_i)}{p(\omega_i)p(p_i)}}
                $$
            </p>
            <figure class="media">
                <img src="../images/sssAssorted50000spp.png" alt="Assorted SSS Renders">
                <figcaption>
                    Assorted models around a spherical light \(L_e = 30\).
                    Dragon: \(\ell= 10.0 , \alpha = 0.2\) Lucy: \(\ell= 7.0 , \alpha = 0.1\) Buddha: \(\ell= 1.0 , \alpha = 0.5\)
                </figcaption>
            </figure>

            <h2>References</h2>
            <ol>
                <li>https://pbr-book.org/3ed-2018/contents</li>
                <li>https://graphics.pixar.com/library/ApproxBSSRDF/paper.pdf</li>
                <li>http://www.graphics.stanford.edu/papers/bssrdf/bssrdf.pdf</li>
                <li>https://media.disneyanimation.com/uploads/production/publication_asset/153/asset/siggraph2016SSS.pdf</li>
                <li>https://gao-duan.github.io/blogs/bssrdf/index.html</li>
                <li>https://agraphicsguynotes.com/posts/practical_tips_for_implementing_subsurface_scattering_in_a_ray_tracer/</li>
                <li>https://zero-radiance.github.io/post/sampling-diffusion/</li>

            </ol>

        </div>
    </div>
</body>

</html>