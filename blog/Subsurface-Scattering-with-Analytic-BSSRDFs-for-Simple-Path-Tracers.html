<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subsurface Scattering with Analytic BSSRDFs for Simple Path Tracers</title>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        body {
            background: #fff;
            color: #222;
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            padding: 0;
        }
        .container {
            max-width: 700px;
            margin: 60px auto 0 auto;
            padding: 32px 24px;
            background: #fff;
            box-shadow: 0 2px 8px rgba(0,0,0,0.04);
            border-radius: 8px;
        }
        h1 {
            font-size: 2.2rem;
            margin-bottom: 0.5em;
            font-weight: 600;
        }
        .post-meta {
            color: #888;
            font-size: 1rem;
            margin-bottom: 2em;
        }
        .post-content {
            font-size: 1.15rem;
            line-height: 1.7;
        }
        a.back-link {
            display: inline-block;
            margin-bottom: 2em;
            color: #0077cc;
            text-decoration: none;
            font-size: 1rem;
        }
        a.back-link:hover {
            text-decoration: underline;
        }
        pre code {
            display: block;
            background: #f5f5f5;
            color: #222;
            padding: 14px 16px;
            border-radius: 6px;
            font-size: 1em;
            line-height: 1.5;
            overflow-x: auto;
            max-width: 100%;
            box-sizing: border-box;
        }
    </style>
</head>
<body>
    <div class="container">
        <a href="index.html" class="back-link">&larr; Back to Blog</a>
        <h1>Subsurface Scattering with Analytic BSSRDFs for Simple Path Tracers</h1>
        <div class="post-meta">Kai Zhang &bull; <!-- Date can be added here --></div>
        <div class="post-content">
            <p>I've been implementing a simple energy conserving path tracer and wanted to add subsurface scattering to it and I found most sources to be scattered. If you want to implement a simple, physically based SSS into your path tracer, I hope I can help.</p>
            <p>In SSS, light enters a point on a surface, then re-emerged at a point that may or may not be where it first entered. Looking at the rendering equation:</p>
            <p>
                $$
                L_o(x, \omega_o) = L_e(x, \omega_o) + \int_{H^2} f_r(x, \omega_i, \omega_o) L_i(x, \omega_i) (\omega_i \cdot n) d\omega_i
                $$
            </p>
            <p>We can see that it only supports light entering and exiting at one point. Therefore we need to expand this with BSSRDF:</p>
            <p>
                $$
                L_o(x_o, \omega_o) = L_e(x_o, \omega_o) + \int_A \int_{H^2} S(x_i, \omega_i, x_o, \omega_o) L_i(x_i, \omega_i) (\omega_i \cdot n_i) d\omega_i dA(x_i)
                $$
            </p>
            <p>As you can see, not only do we have a hemisphere around our point but we must also consider the area surrounding it.</p>
            <p>Of course the integral in this form is quite difficult to evaluate (it has 8 dimensions!). Luckily in 2001, <a href="http://www.graphics.stanford.edu/papers/bssrdf/bssrdf.pdf" target="_blank" rel="noopener noreferrer">Jensen et al proposed a more manageable form</a> of the BSSRDF term called the separable BSSRDF:</p>
            <p>
                $$
                S(p_o, \omega_o, p_i, \omega_i) = (1 - F(\omega_o)) S_p(p_o, p_i) S_\omega(\omega_i)
                $$
            </p>
            <p>I will now explain how to integrate each term into your Monte Carlo path tracer.</p>
            <div style="margin-top:2em;">\((1 - F(\omega_o))\)</div>
            <p>This term essentially accounts for whether the light actually enters the surface and scatters. Therefore, we can just use it as a test to see if we actually need to evaluate the BSSRDF. Draw a random number uniformly \(u_1 \in [0, 1]\) and test \(u_1 < 1 - F(\omega_o)\). If it fails, simply fall back to something like a reflection lobe.</p>
            <div style="margin-top:2em;">\(S_\omega(\omega_i)\)</div>
            <p>This term accounts for the energy loss when the ray exits the surface. Here is the function (from <a href="https://pbr-book.org/3ed-2018/Volume_Scattering/The_BSSRDF" target="_blank" rel="noopener noreferrer">pbrt 11.7</a>):</p>
            <p>
                $$
                S_\omega(\omega_i) = \frac{1 - F_r(\cos \theta_i)}{c \pi}
                $$
            </p>
            <p>where</p>
            <p>
                $$
                c = 1 - 2 \int_0^{\frac{\pi}{2}} F_r(\eta, \cos \theta) \sin \theta \cos \theta \, d\theta
                $$
            </p>
            <p>This integral can be precomputed using this function:</p>
            <pre><code>__device__ inline float FresnelMoment1(float invEta)
{
    float e = invEta;
    float e2 = e * e, e3 = e2 * e, e4 = e2 * e2, e5 = e3 * e2;
    if (e < 1.0f)
        return 0.45966f - 1.73965f * e + 3.37668f * e2 - 3.904945f * e3 + 2.49277f * e4 - 0.68441f * e5;
    else
        return -4.61686f + 11.1136f * e - 10.4646f * e2 + 5.11455f * e3 - 1.27198f * e4 + 0.12746f * e5;
}
</code></pre>
            <p>Please refer to <a href="https://pbr-book.org/3ed-2018/Volume_Scattering/The_BSSRDF#SeparableBSSRDFs" target="_blank" rel="noopener noreferrer">pbrt 11.4.3</a> for derivation.</p>
            <div style="margin-top:2em;">\(S_p(p_o, p_i)\)</div>
            <p>This term is the spatial term and accounts for energy when the light scatters under the surface. We make the simplifying assumption:</p>
            <p>
                $$
                S_p(p_o, p_i) = S_r(\|p_o - p_i\|)
                $$
            </p>
            <p>So that the only factor affecting this term is the distance between the entrance and exit of the light. This has many different variations called diffusion profiles, which generally are functions that approximate the area integral. I decided to use <a href="https://graphics.pixar.com/library/ApproxBSSRDF/paper.pdf" target="_blank" rel="noopener noreferrer">this one described by Brent Burley et al. in 2015</a>:</p>
            <p>
                $$
                R(r) = A s \frac{e^{-sr/\ell} + e^{-sr/(3\ell)}}{8 \pi \ell r}
                $$
            </p>
            <p>Here \(r\) is the distance from the entrance and exit points. \(\ell\) is the mean free path which essentially controls how far the light scatters under the surface before reemerging. \(s\) is the shape parameter, defined as</p>
            <p style="text-align:center; margin: 1.5em 0;">
                $$
                s = 1.85 - A + 7|A - 0.8|^3
                $$
            </p>
            <p>Where \(A\) is albedo. Note that since albedo is usually a <code>vec3</code>, I chose to approximate it with a luminance function:</p>
            <pre style="margin: 1.5em 0;"><code>__device__ inline float Luminance(const glm::vec3& col)
{
    const glm::vec3 lumaWeights(0.2126f, 0.7152f, 0.0722f);
    return glm::dot(col, lumaWeights);
}
</code></pre>
            <p>This is purely an artistic choice, so you can define it however you want, as long as \(s > 0\).</p>
            <p>Finally, \(A\) in the diffusion profile represents again an albedo, but this time you should use <a href="https://www.pbr-book.org/3ed-2018/Volume_Scattering/The_BSSRDF#eq:bssrdf-effective-albedo" target="_blank" rel="noopener noreferrer">effective albedo as described in pbrt 11.11</a>.</p>
            <p>The effective albedo is defined as</p>
            <p>
                $$
                \rho_{\mathrm{eff}} = \int_0^{2\pi} \int_0^{\infty} r S_r(r) \, dr \, d\phi = 2\pi \int_0^{\infty} r S_r(r) \, dr.
                $$
            </p>
            <p>Luckily for us, Burley's diffusion profile is normalized, meaning this simply integrates to \(A\).</p>
            <h2>Importance Sampling</h2>
            <p>The next question is, how do we decide our enter and exit points \(p_i\), \(p_o\) to evaluate the separable BSSRDF? We need to use importance sampling. Essentially I will describe a simplified version of the disk sampling described in <a href="https://pbr-book.org/3ed-2018/Light_Transport_II_Volume_Rendering/Sampling_Subsurface_Reflection_Functions" target="_blank" rel="noopener noreferrer">pbrt 15.4</a>.</p>
            <p>So let's say you shoot a ray into the scene, it intersects a surface and passes the <span style="white-space:nowrap;">\((1 - F(\omega_o))\)</span> test, meaning it has entered the surface</p>
            <ol style="margin-left:1.5em;">
                <li>Get the point of intersection and its normal. That is your <span style="white-space:nowrap;">\(p_o\)</span>.</li>
                <li>Draw a sphere at that point that encapsulates 99.9% of the energy of the diffusion profile. Everything outside of it is negligible.
                  <div style="margin-left:1.5em; color:#797979; font-size:0.97em;">
                    <em>Explanation on how to get radius of this sphere in upcoming section.</em>
                  </div>
                </li>
                <li>Create a disk that is tangent to the surface and has the radius which is the same as the max energy sphere.</li>
                <li>Choose a point on that disk based on the diffusion profile's CDF.
                  <div style="margin-left:1.5em; color:#797979; font-size:0.97em;">
                    <em>I’ll explain how to sample the diffusion profile’s CDF in the upcoming section.</em>
                  </div>
                </li>
                <li>Cast a probe ray at that point, parallel to the normal, whose length is based on the size of the sphere.</li>
                <li>Gather every intersection in a linked list, and remove any that are not apart of the model. (For example, a wall near the model.)</li>
                <li>Uniformly choose a random intersection point. Get the normal and position of that intersection. That is your <span style="white-space:nowrap;">\(p_i\)</span>.</li>
            </ol>
            <h2>Sampling on a Disk with Burley's Diffusion Profile</h2>
            <p>Previously I mentioned we must choose a point on that disk based on the diffusion profile's CDF. This is the importance sampling part. Essentially, we want to pick points on the disk that give the most contribution to our evaluation of <span style="white-space:nowrap;">\(R(r)\)</span>.</p>
            <p>Burley provided us with a perfect CDF in the paper:</p>
            <p>
                $$
                \text{CDF}(r) = 1 - \frac{1}{4} e^{-r/d} - \frac{3}{4} e^{-r/(3d)}
                $$
            </p>
            <p>Although the original paper claims this CDF is not analytically invertible, Zero Radiance in 2019 proved it actually was:</p>
            <p style="text-align:center; margin: 1.5em 0;">
                $$
                x = sr = 3 \log\left(\frac{1 + G(u)^{-1/3} + G(u)^{1/3}}{4u}\right),
                $$
            </p>
            <p style="text-align:center; margin: 1.5em 0;">
                $$
                G(u) = 1 + 4u\left(2u + \sqrt{1 + 4u^2}\right)
                $$
            </p>
            <p>So here is the code that gives you a radial distance on the disk based on that inverse CDF (directly from Zero Radiance's Blog):</p>
            <pre style="margin: 1.5em 0;"><code>__device__ inline void SampleBurleyRadius(float u, float rcpS, float& r, float& rcpPdf)
{
    const float LOG2_E = 1.44269504089f;
    u = 1.0f - u; 

    float g = 1.0f + (4.0f * u) * (2.0f * u + sqrtf(1.0f + (4.0f * u) * u));
    float n = exp2f(log2f(g) * (-1.0f / 3.0f));             
    float p = (g * n) * n;                         
    float c = 1.0f + p + n;                                  
    float x = (3.0f / LOG2_E) * log2f(c / (4.0f * u));       
    float rcpExp = ((c * c) * c) / ((4.0f * u) * ((c * c) + (4.0f * u) * (4.0f * u)));

    r = x * rcpS;
    rcpPdf = (8.0f * pi * rcpS) * rcpExp;
}
</code></pre>
            <p>Again, I'm using the luminance approximation to calculate <code>s</code>. Please note that the above code assumes \(\ell = 1\). To convert it to take in any \(\ell\), simply multiply:</p>
            <pre style="margin: 0.5em 0 1.5em 0;"><code>r *= ell;
</code></pre>
            <p>Even though this function also nicely provides a PDF, we won't use it so we can use our own for clarity. But by all means, if you don't mind, you can use the one returned by the function.</p>
            <p>Once you have that radial distance \(r\), draw a random \(\phi \in [0, 2\pi]\) uniformly for the azimuthal angle on the disk. You have now successfully sampled a point on the disk in polar coordinates \(p(r, \phi)\).</p>
            <p>You can convert this into a world space vector as
                \[
                r (\cos(\phi)\, \mathbf{T} + \sin(\phi)\, \mathbf{B})
                \]
            where \(\mathbf{T}\) and \(\mathbf{B}\) are the tangent and bitangent vectors of the disk's plane.</p>
        </div>
    </div>
</body>
</html>